#****************************************************************************
#* test_api_gen_sv_filtering.py
#*
#* Tests for api-gen-sv module filtering functionality
#*
#****************************************************************************
import io
import os
import sys
import pytest

# Add src directory to Python path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'src'))

from hdl_if.decorators import api, exp, imp
from hdl_if.impl.call.api_def_rgy import ApiDefRgy
from hdl_if.impl.call.ctor import Ctor
from hdl_if.impl.call.gen_sv_class import GenSVClass
from hdl_if.cmd.cmd_api_gen_sv import CmdApiGenSV
import ctypes as ct


class MockArgs:
    """Mock argument object for testing CmdApiGenSV."""
    def __init__(self, **kwargs):
        self.module = kwargs.get('module', [])
        self.uvm = kwargs.get('uvm', False)
        self.deprecated = kwargs.get('deprecated', False)
        self.include = kwargs.get('include', None)
        self.exclude = kwargs.get('exclude', None)
        self.follow_deps = kwargs.get('follow_deps', False)
        self.package = kwargs.get('package', None)
        self.output = kwargs.get('output', '/dev/null')


def _get_generated_class_names(sv_content):
    """Extract class names from generated SV content."""
    import re
    # Match interface class and class declarations
    pattern = r'^(?:interface\s+)?class\s+(\w+)'
    return re.findall(pattern, sv_content, re.MULTILINE)


class TestApiGenSvFiltering:
    """Tests for API filtering in api-gen-sv command."""

    def setup_method(self):
        """Reset registries before each test."""
        ApiDefRgy.init()
        Ctor.init()

    def test_filter_to_loaded_modules_only(self, tmp_path):
        """Test that only APIs from explicitly loaded modules are generated by default."""
        # Define a base API class (simulating hdl_if.uvm.wrap.component)
        @api
        class BaseApi:
            def __init__(self):
                pass

            @imp
            def base_method(self) -> int:
                pass

        # Define a user API class that inherits from BaseApi
        @api
        class UserApi(BaseApi):
            def __init__(self):
                super().__init__()

            @exp
            def user_method(self, x: int) -> int:
                return x

        # Get all registered APIs
        all_apis = ApiDefRgy.inst().getApis()
        assert len(all_apis) == 2  # BaseApi and UserApi

        # Create command and filter
        cmd = CmdApiGenSV()

        # Both APIs are in this test module
        test_module = self.__class__.__module__
        filtered = cmd._filter_apis(all_apis, [test_module], MockArgs())

        # Both should be included since both are in the test module
        assert len(filtered) == 2

    def test_filter_excludes_dependency_modules(self, tmp_path):
        """Test that APIs from dependency modules are excluded by default."""
        # We need to test the module prefix matching
        cmd = CmdApiGenSV()
        
        # Create mock API objects with different module prefixes
        class MockApi:
            def __init__(self, fullname):
                self.fullname = fullname
                self.pycls = None
        
        all_apis = [
            MockApi("hdl_if.uvm.wrap.object.uvm_object"),
            MockApi("hdl_if.uvm.wrap.component.uvm_component"),
            MockApi("mymodule.MyUserClass"),
            MockApi("mymodule.submod.AnotherClass"),
        ]
        
        # Filter to only "mymodule"
        filtered = cmd._filter_apis(all_apis, ["mymodule"], MockArgs())
        
        # Should only include mymodule.* APIs
        assert len(filtered) == 2
        fullnames = [a.fullname for a in filtered]
        assert "mymodule.MyUserClass" in fullnames
        assert "mymodule.submod.AnotherClass" in fullnames
        assert "hdl_if.uvm.wrap.object.uvm_object" not in fullnames
        assert "hdl_if.uvm.wrap.component.uvm_component" not in fullnames

    def test_follow_deps_includes_base_classes(self):
        """Test that --follow-deps includes base class APIs."""
        @api
        class GrandparentApi:
            def __init__(self):
                pass

            @imp
            def grandparent_method(self) -> int:
                pass

        @api
        class ParentApi(GrandparentApi):
            def __init__(self):
                super().__init__()

            @imp
            def parent_method(self) -> int:
                pass

        @api
        class ChildApi(ParentApi):
            def __init__(self):
                super().__init__()

            @exp
            def child_method(self, x: int) -> int:
                return x

        all_apis = ApiDefRgy.inst().getApis()
        assert len(all_apis) == 3

        cmd = CmdApiGenSV()
        api_by_fullname = {a.fullname: a for a in all_apis}
        
        # Find ChildApi
        child_api = next(a for a in all_apis if "ChildApi" in a.fullname)
        
        # Collect deps
        deps = set()
        cmd._collect_deps(child_api, api_by_fullname, deps)
        
        # Should include both ParentApi and GrandparentApi
        assert len(deps) == 2
        dep_names = [d.split('.')[-1] for d in deps]
        assert "ParentApi" in dep_names
        assert "GrandparentApi" in dep_names

    def test_follow_deps_flag(self):
        """Test that --follow-deps flag properly includes dependencies."""
        @api
        class BaseForFollowDeps:
            def __init__(self):
                pass

            @imp
            def base_m(self) -> int:
                pass

        @api
        class DerivedForFollowDeps(BaseForFollowDeps):
            def __init__(self):
                super().__init__()

            @exp
            def derived_m(self, x: int) -> int:
                return x

        all_apis = ApiDefRgy.inst().getApis()
        cmd = CmdApiGenSV()

        # Create mock API objects with different module prefixes but preserve pycls
        class MockApiWithModule:
            def __init__(self, original, new_fullname):
                self.fullname = new_fullname
                self.pycls = original.pycls
                self.methods = original.methods
                self.init_params = original.init_params

        # Remap APIs to simulate different modules
        base_api = next(a for a in all_apis if "BaseForFollowDeps" in a.fullname)
        derived_api = next(a for a in all_apis if "DerivedForFollowDeps" in a.fullname)
        
        mock_base = MockApiWithModule(base_api, "hdl_if.base.BaseForFollowDeps")
        mock_derived = MockApiWithModule(derived_api, "usermod.DerivedForFollowDeps")
        
        mock_apis = [mock_base, mock_derived]
        
        # Build the api_by_fullname map that _collect_deps uses
        # The key insight: _collect_deps looks up base classes by their actual class fullname
        # (cls.__module__ + "." + cls.__qualname__), not the mock fullname
        # So we need the api_by_fullname map to include the original fullnames too
        
        # Without follow_deps
        args_no_deps = MockArgs(follow_deps=False)
        filtered_no_deps = cmd._filter_apis(mock_apis, ["usermod"], args_no_deps)
        assert len(filtered_no_deps) == 1
        assert "DerivedForFollowDeps" in filtered_no_deps[0].fullname

        # With follow_deps - the MRO lookup uses cls.__module__ + "." + cls.__qualname__
        # which would be the test module name, not our mocked "hdl_if.base" prefix
        # This test verifies the mechanism works when fullnames match the actual class location
        args_with_deps = MockArgs(follow_deps=True)
        
        # Use original APIs for this test since _collect_deps relies on actual class MRO
        original_base = base_api
        original_derived = derived_api
        test_module = self.__class__.__module__
        
        # Filter to just the derived, then check deps are found
        # We simulate by putting derived in a "user" module prefix
        class MockApiOriginal:
            def __init__(self, original, new_fullname):
                self.fullname = new_fullname
                self.pycls = original.pycls
                self.methods = getattr(original, 'methods', [])
                self.init_params = getattr(original, 'init_params', [])
        
        # Create mock APIs where base is in "lib" and derived is in "user"
        # But the pycls MRO will still point to the real classes
        mock_base2 = MockApiOriginal(original_base, "lib.BaseForFollowDeps")
        mock_derived2 = MockApiOriginal(original_derived, "user.DerivedForFollowDeps")
        
        # Also need to include an entry for the actual class fullname so _collect_deps can find it
        actual_base_fullname = original_base.pycls.__module__ + "." + original_base.pycls.__qualname__
        mock_base_actual = MockApiOriginal(original_base, actual_base_fullname)
        
        mock_apis2 = [mock_base2, mock_derived2, mock_base_actual]
        
        filtered_with_deps = cmd._filter_apis(mock_apis2, ["user"], args_with_deps)
        
        # Should include derived + base (found via MRO lookup using actual fullname)
        assert len(filtered_with_deps) >= 2

    def test_include_pattern(self):
        """Test that -i/--include patterns filter correctly."""
        cmd = CmdApiGenSV()
        
        class MockApi:
            def __init__(self, fullname):
                self.fullname = fullname
                self.pycls = None
        
        all_apis = [
            MockApi("mymod.ClassA"),
            MockApi("mymod.ClassB"),
            MockApi("mymod.sub.ClassC"),
        ]
        
        # Include only ClassA
        args = MockArgs(include=["*ClassA"])
        filtered = cmd._filter_apis(all_apis, ["mymod"], args)
        assert len(filtered) == 1
        assert filtered[0].fullname == "mymod.ClassA"
        
        # Include pattern with wildcard
        args = MockArgs(include=["*sub*"])
        filtered = cmd._filter_apis(all_apis, ["mymod"], args)
        assert len(filtered) == 1
        assert filtered[0].fullname == "mymod.sub.ClassC"

    def test_exclude_pattern(self):
        """Test that -e/--exclude patterns filter correctly."""
        cmd = CmdApiGenSV()
        
        class MockApi:
            def __init__(self, fullname):
                self.fullname = fullname
                self.pycls = None
        
        all_apis = [
            MockApi("mymod.ClassA"),
            MockApi("mymod.ClassB"),
            MockApi("mymod.internal.ClassC"),
        ]
        
        # Exclude internal classes
        args = MockArgs(exclude=["*internal*"])
        filtered = cmd._filter_apis(all_apis, ["mymod"], args)
        assert len(filtered) == 2
        fullnames = [a.fullname for a in filtered]
        assert "mymod.ClassA" in fullnames
        assert "mymod.ClassB" in fullnames
        assert "mymod.internal.ClassC" not in fullnames

    def test_include_and_exclude_combined(self):
        """Test that include and exclude patterns work together."""
        cmd = CmdApiGenSV()
        
        class MockApi:
            def __init__(self, fullname):
                self.fullname = fullname
                self.pycls = None
        
        all_apis = [
            MockApi("mymod.PublicA"),
            MockApi("mymod.PublicB"),
            MockApi("mymod.PrivateA"),
            MockApi("mymod.PrivateB"),
        ]
        
        # Include Public*, exclude *B
        args = MockArgs(include=["*Public*"], exclude=["*B"])
        filtered = cmd._filter_apis(all_apis, ["mymod"], args)
        assert len(filtered) == 1
        assert filtered[0].fullname == "mymod.PublicA"

    def test_api_in_modules_prefix_matching(self):
        """Test module prefix matching logic."""
        cmd = CmdApiGenSV()
        
        class MockApi:
            def __init__(self, fullname):
                self.fullname = fullname
        
        # Test various module prefix scenarios
        api1 = MockApi("mymod.Class")
        api2 = MockApi("mymod.sub.Class")
        api3 = MockApi("mymodule.Class")  # Different module, not a submodule
        api4 = MockApi("other.Class")
        
        modules = ["mymod"]
        
        assert cmd._api_in_modules(api1, modules) == True
        assert cmd._api_in_modules(api2, modules) == True
        assert cmd._api_in_modules(api3, modules) == False  # mymodule != mymod
        assert cmd._api_in_modules(api4, modules) == False

    def test_multiple_modules(self):
        """Test filtering with multiple -m modules specified."""
        cmd = CmdApiGenSV()
        
        class MockApi:
            def __init__(self, fullname):
                self.fullname = fullname
                self.pycls = None
        
        all_apis = [
            MockApi("mod1.ClassA"),
            MockApi("mod2.ClassB"),
            MockApi("mod3.ClassC"),
        ]
        
        # Load mod1 and mod2
        filtered = cmd._filter_apis(all_apis, ["mod1", "mod2"], MockArgs())
        assert len(filtered) == 2
        fullnames = [a.fullname for a in filtered]
        assert "mod1.ClassA" in fullnames
        assert "mod2.ClassB" in fullnames
        assert "mod3.ClassC" not in fullnames

    def test_generated_class_includes_inherited_methods(self):
        """Test that generated SV class includes methods from base API classes."""
        @api
        class BaseWithMethods:
            def __init__(self):
                pass

            @imp
            def base_imp_method(self, a: int) -> int:
                return a

            @exp
            def base_exp_method(self, b: int) -> int:
                return b

        @api
        class DerivedWithMethods(BaseWithMethods):
            def __init__(self):
                super().__init__()

            @exp
            def derived_method(self, x: int) -> int:
                return x

        # Get the DerivedWithMethods API
        all_apis = ApiDefRgy.inst().getApis()
        derived_api = next(a for a in all_apis if "DerivedWithMethods" in a.fullname)
        
        # Generate SV for just the derived class
        out = io.StringIO()
        gen = GenSVClass(out, ind="", uvm=False, deprecated=False)
        gen.gen(derived_api)
        sv_content = out.getvalue()
        
        # The generated class should include methods from both base and derived
        assert "derived_method" in sv_content
        assert "base_imp_method" in sv_content
        assert "base_exp_method" in sv_content

    def test_empty_result_raises_exception(self, tmp_path):
        """Test that filtering to zero APIs raises an appropriate exception."""
        cmd = CmdApiGenSV()
        
        class MockApi:
            def __init__(self, fullname):
                self.fullname = fullname
                self.pycls = None
        
        all_apis = [
            MockApi("othermod.Class"),
        ]
        
        # Filter to a module with no APIs
        args = MockArgs()
        filtered = cmd._filter_apis(all_apis, ["nonexistent"], args)
        assert len(filtered) == 0

    def test_preserve_registration_order(self):
        """Test that filtered APIs maintain their original registration order."""
        @api
        class First:
            def __init__(self):
                pass

        @api
        class Second:
            def __init__(self):
                pass

        @api
        class Third:
            def __init__(self):
                pass

        all_apis = ApiDefRgy.inst().getApis()
        cmd = CmdApiGenSV()

        # Filter using the actual test module name
        test_module = self.__class__.__module__
        filtered = cmd._filter_apis(all_apis, [test_module], MockArgs())

        # Order should match registration order
        assert len(filtered) == 3
        names = [a.name for a in filtered]
        assert names == ["First", "Second", "Third"]
